<script type="text/javascript">
 RED.nodes.registerType('beat',{
     category: 'music',
     color: '#a6bbcf',
     defaults: {
	 name: {value:""},
	 output: {value:"beat"},
	 bpm: {value: 200},
	 latency: {value: 0},
	 subBeats: {value: []}
     },
     inputs:1,
     outputs:1,
     icon: "file.png",
     label: function() {
	 return this.name||"beat";
     },

     oneditprepare: function(){
	 node = this;
	 node.subBeats = node.subBeats || [];
	 $('#node-input-sub-beat-container').editableList({
	     addItem: function(container,i,subBeat) {
		 var row = $('<div/>').appendTo(container);
		 $("<span>Sub-beat </span>").appendTo(row);
		 var nameField = $('<input/>',{class: "node-input-sub-beat-name",  type:"text", size: 15, placeholder:"e.g. triplet", style:"width:10em"}).appendTo(row);
		 $("<span> # per beat </span>").appendTo(row);
		 var countField = $('<input/>',{class: "node-input-sub-beat-count",  type:"number", size:6, placeholder: "e.g. 3", style:"width:6em"}).appendTo(row);

		 nameField.val(subBeat.name);
		 countField.val(subBeat.count);
	     },

	     removable: true
	 });

	 for (var i=0;i<node.subBeats.length;i++) {
             var subBeat = node.subBeats[i];
             $("#node-input-sub-beat-container").editableList('addItem',subBeat);
         }
     },

     oneditsave: function(){
	 var subBeats = $("#node-input-sub-beat-container").editableList('items');
	 var node = this;
	 node.subBeats = [];
	 subBeats.each(function(i){
	     var name = $(this).find(".node-input-sub-beat-name").val();
	     var count = $(this).find(".node-input-sub-beat-count").val();
	     node.subBeats.push({name: name, count: count});
	 });
     }
 });
</script>

<script type="text/x-red" data-template-name="beat">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-output"><i class="icon-tag"></i> Output counter</label>
    <input type="text" id="node-input-output" placeholder="e.g. beat)">
  </div>
  <div class="form-row">
    <label for="node-input-bpm"><i class="icon-tag"></i> Initial beats per minute</label>
    <input type="text" id="node-input-bpm" placeholder="BPM (e.g. 200)">
  </div>
  <div class="form-row">
    <label for="node-input-latency"><i class="icon-tag"></i> Latency</label>
    <input type="text" id="node-input-latency" placeholder="In milliseconds">
  </div>
  <div class="form-row node-input-sub-beat-container-row">
    <label><b>Sub-beats</b> Enter the name and number per beat</label>
    <ol id="node-input-sub-beat-container"></ol>
  </div>
</script>

<script type="text/x-red" data-help-name="beat">
  <p>The beat generator ouputs ticks at a regular interval once it has started, like a metronome.</p>
  <p>The output message has the payload "tick". The number of ticks is counted and included in the output message. By default the tick count is sent in <code>msg.beat</code> but this can be changed with the <b>Output counter</b> property.</p>
  <p>Initially the number of beats per minute is set by the <b>BPM</b> property, with a default of 200. This can be altered by sending a message to the beat generator with <code>msg.topic</code> and the required beats-per-minute in <code>msg.payload</code></p>
  <p>If you set the <b>Latency</b> property then beats will be sent with a timeTag when the beat should occur, including the latency required. Including latency allows for more accurate placement of beats. If the latency is too small you will get "late" messages from supercollider, indicating that the request didn't seach supercollider in time to be executed. Increasing the latency allows more time for the beats to propogate through the node-red flows and to be sent to supercollider.</p>
  <p>To start the beat generator, send it a message with <code>msg.payload</code> as <code>start</code>.</p>
  <p>A message with a payload of <code>stop</code> payload will stop (pause) the generator. If the generator is started again then the tick count will continue from where it left off.</p>
  <p>To start counting from 0 again, send a message with a payload of <code>reset</code>. Any reset messages will also be forwarded to the output of the node, as will any other input messages that do not have the topic <code>bpm</code> and do not have the payload <code>start</code> or <code>stop</code>.</p>

</script>
